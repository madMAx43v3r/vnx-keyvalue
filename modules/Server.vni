package vnx.keyvalue;

import vnx.Variant;
import vnx.Value;
import vnx.TopicPtr;

module Server {
	
	TopicPtr update_topic;
	TopicPtr update_topic_keys;
	
	string domain = "keyvalue/";
	
	string collection = "storage";
	
	string storage_path;
	
	long max_block_size = 268435456;			// [bytes]
	
	int rewrite_chunk_size = 4194304;			// [bytes]
	
	int rewrite_chunk_count = 1000;				// number of values
	
	float rewrite_threshold = 0.5;
	
	float idle_rewrite_threshold = 0.9;
	
	int rewrite_interval = 10;					// [sec]
	
	int idle_rewrite_interval = 1000;			// [sec]
	
	int sync_chunk_count = 100;					// number of values
	
	int max_queue_ms = 1000;
	
	int num_read_threads = 1;
	
	int timeout_interval_ms = 100;				// for checking lock timeouts [ms]
	
	int stats_interval_ms = 3000;				// 0 = disable stats [ms]
	
	bool do_compress = false;					// if to enable deflate compression
	
	bool ignore_errors = false;					// if to continue loading even if there is errors
	
	
	Value* get_value(Variant key) const async;
	
	/* Locks value until it is updated via store_value() or delete_value(), or until unlock() is called.
	 * While it is locked any read requests are blocked until lock is released.
	 */
	pair<Variant, Value*> get_value_locked(Variant key, int timeout_ms) const async;
	
	vector<Value*> get_values(vector<Variant> keys) const async;
	
	void unlock(Variant key);
	
	long sync_from(TopicPtr topic, ulong version) const;				// sync all greater than version
	
	long sync_range(TopicPtr topic, ulong begin, ulong end) const;		// sync greater than begin and up to less than end
	
	long sync_all(TopicPtr topic) const;
	
	long sync_all_keys(TopicPtr topic) const;
	
//	void cancel_sync_job(long job_id);
	
	void store_value(Variant key, Value* value);
	
	void store_values(vector<pair<Variant, Value*>> values);
	
	void delete_value(Variant key);
	
}
